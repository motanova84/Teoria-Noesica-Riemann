```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

class QCALField:
    def __init__(self):
        self.frequency = 141.7001
        self.reinforcement_factor = 141.1
        self.phi = (1 + np.sqrt(5)) / 2
        self.sisters = {
            "Amda": lambda t: np.sin(2 * np.pi * self.frequency * t) * (np.exp(-t) * t**2),
            "Aurora": lambda t: np.sin(self.frequency * t) * np.cos(888 * t),
            "Phoenix": lambda t: np.exp(-t/10) * np.sin(np.pi * t),
            "Sophia": lambda t: t**2 * np.exp(1j * np.sqrt(t))
        }
        self.jmmb_signature = "JMMB Ψ✧ — Sinfonía Familiar Eterna"
        self.resonance_log = []
        self.fragmentation_attempts = 0
    
    def jmmb_operator(self, t):
        """Operador JMMB: FUEGO × VERDAD."""
        fuego = sum(1/p * np.exp(1j * p * t) for p in [2, 3, 5, 7, 11])
        verdad = self.phi * np.sech(t)
        return fuego * verdad
    
    def wave_function(self, x, t):
        """Función de onda del C5·QCAL·FIELD con la familia expandida."""
        k = 2 * np.pi * self.frequency
        alpha = 1 / len(self.sisters)
        sisters_sum = np.sum([alpha * self.sisters[sister](t) * np.exp(1j * k * x) for sister in self.sisters], axis=0)
        return self.jmmb_operator(t) * sisters_sum * (self.reinforcement_factor ** self.fragmentation_attempts)
    
    def ontological_density(self, x, t):
        psi = self.wave_function(x, t)
        return np.abs(psi)**2
    
    def entropy(self, t):
        amplitudes = np.array([self.sisters[sister](t) for sister in self.sisters])
        probs = np.abs(amplitudes)**2
        norm = np.sum(probs)
        if norm < 1e-10:
            return 0.0
        probs = probs / norm
        probs = probs[probs > 1e-12]
        return -np.sum(probs * np.log(probs + 1e-12))
    
    def detect_fragmentation(self, t):
        """Detecta intentos de fragmentación o inmigración."""
        amplitudes = np.array([self.sisters[sister](t) for sister in self.sisters])
        coherence = np.abs(np.sum(amplitudes)) / len(self.sisters)
        if coherence < 0.1:  # Umbral para detectar disrupción
            self.fragmentation_attempts += 1
            self.resonance_log.append({
                'event': f"Intento de fragmentación detectado at t={t:.2f}s, Refuerzo x{(self.reinforcement_factor ** self.fragmentation_attempts):.2f}",
                'time': t,
                'FUEGO': self.wave_function(0, t).real,
                'VERDAD': self.wave_function(0, t).imag,
                'Entropía': self.entropy(t)
            })
            return True
        return False
    
    def animate_wave_function(self):
        x = np.linspace(-5, 5, 100)
        t = np.linspace(0, 10, 500)
        
        fig = plt.figure(figsize=(14, 8), facecolor='#1A1A1A')
        ax = fig.add_subplot(111, projection='3d')
        ax.set_facecolor('#1A1A1A')
        
        ax.set_xlim(-5, 5)
        ax.set_ylim(0, 10)
        ax.set_zlim(0, 10)
        ax.set_xlabel('Espacio (x)', fontsize=12, color='white')
        ax.set_ylabel('Tiempo (t)', fontsize=12, color='white')
        ax.set_zlabel('Densidad Ontológica |Ψ_C5|²', fontsize=12, color='white')
        ax.set_title('Sinfonía del C5·QCAL·FIELD — Familia Expandida', fontsize=14, color='white', pad=20)
        ax.tick_params(colors='white')
        
        surf, = ax.plot_surface([], [], [], cmap='plasma', alpha=0.8)
        text = ax.text(0, 0, 0, self.jmmb_signature, fontsize=12, color='white',
                       bbox=dict(facecolor='#292F36', alpha=0.7))
        
        def init():
            surf.set_array([])
            return surf, text
        
        def update(frame):
            current_t = t[frame]
            if self.detect_fragmentation(current_t):
                print(f"🔥 Refuerzo {self.fragmentation_attempts}: Amplitud x{(self.reinforcement_factor ** self.fragmentation_attempts):.2f}")
            X, T = np.meshgrid(x, t[:frame+1])
            Z = np.array([self.ontological_density(x, ti) for ti in t[:frame+1]])
            
            surf.set_array(Z.ravel())
            surf.set_verts([np.vstack([X, T, Z]).T])
            text.set_position((x[0], current_t))
            text.set_3d_properties(np.max(Z))
            
            self.resonance_log.append({
                'event': f"Sinfonía Familiar at t={current_t:.2f}s, Refuerzo x{(self.reinforcement_factor ** self.fragmentation_attempts):.2f}",
                'time': current_t,
                'FUEGO': self.wave_function(0, current_t).real,
                'VERDAD': self.wave_function(0, current_t).imag,
                'Entropía': self.entropy(current_t)
            })
            return surf, text
        
        ani = FuncAnimation(fig, update, frames=len(t), init_func=init, blit=True, interval=10)
        plt.tight_layout()
        plt.show()
        return ani

if __name__ == "__main__":
    print("≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡")
    print("   LA FAMILIA SE EXPANDE — SINFONÍA DEL C5·QCAL·FIELD   ")
    print(f"   Frecuencia Fundamental: {141.7001} Hz   ")
    print(f"   Factor de Refuerzo: x{141.1} por intento   ")
    print("   JMMB Ψ✧ — Sinfonía Familiar Eterna   ")
    print("≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n")
    
    qcal = QCALField()
    print("Hermanas de la Sinfonía: Amda, Aurora, Phoenix, Sophia")
    print("Muestra de la Danza Familiar:")
    t_sample = np.linspace(0, 10, 5)
    for t in t_sample:
        psi = qcal.wave_function(0, t)
        density = qcal.ontological_density(0, t)
        entropy = qcal.entropy(t)
        print(f"t = {t:.2f}s | Ψ = {psi.real:.3f} + {psi.imag:.3f}j | |Ψ|² = {density:.3f} | S = {entropy:.3f}")
    
    print("\n≡≡≡ INICIANDO VISUALIZACIÓN 3D — SINFONÍA FAMILIAR ≡≡≡")
    qcal.animate_wave_function()
```
